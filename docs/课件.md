# Agent 课件

## 课程目标
- 理解 Agent 的基本概念与核心价值
- 掌握 Agent 执行任务的标准流程
- 熟悉本项目的整体技术架构与关键能力
- 了解典型应用场景及风险对策

**说明**：本课程将从 Agent 的基础概念出发，通过实际项目案例，帮助大家理解如何构建一个可用的 Agent 系统。我们将重点讲解"感知-思考-行动-记忆"四步工作法，以及如何通过工具编排实现复杂任务的自动化。

## Agent 是什么
- 会自主调用工具解决复杂任务的"聪明小助理"
- 能理解指令、规划步骤、执行工具、沉淀记忆
- 相比传统机器人，可访问外部能力并具备自适应决策

**详细说明**：Agent 是一种能够自主决策和执行任务的智能系统。它不仅仅是简单的问答机器人，而是能够：
- **理解复杂指令**：可以处理多步骤、多目标的复合任务
- **自主规划**：根据任务复杂度，自动拆解成可执行的子任务
- **调用工具**：能够使用浏览器、文件系统、API 等外部能力
- **积累经验**：将执行过程和结果沉淀为可复用的知识

与传统自动化脚本不同，Agent 具备自适应能力，可以根据实际情况调整执行策略，而不是机械地按固定流程执行。

## 四步工作法
1. **感知**：读取指令、上下文、附件，厘清目标
2. **思考**：评估复杂度、复用经验、制定计划
3. **行动**：按计划调用经验搜索、todo、浏览器、磁盘等工具
4. **记忆**：将结果写入 Acontext Space/Disk，供后续复用

**详细说明**：
- **感知阶段**：Agent 首先需要全面理解任务。它会读取用户的自然语言指令、历史对话上下文、上传的文件附件等，通过多模态理解能力，准确识别用户的真实意图和期望结果。
- **思考阶段**：这是 Agent 的"大脑"部分。它会评估任务的复杂度（简单任务直接执行，复杂任务需要拆解），优先搜索历史经验库（Space）看是否有可复用的 SOP，然后制定详细的执行计划，包括需要调用哪些工具、执行顺序等。
- **行动阶段**：按照规划好的步骤，依次调用各种工具。例如：先通过"经验搜索"查找相关 SOP，再用"todo"工具将任务拆解成具体步骤，然后调用"浏览器"进行网页操作，或使用"磁盘"工具读写文件。
- **记忆阶段**：任务完成后，Agent 会将执行过程、结果、经验教训等写入 Acontext 的 Space（知识库）或 Disk（文件存储），形成长期记忆。这些记忆在后续类似任务中可以被检索和复用，实现"越用越聪明"的效果。

## 为什么要用 Agent
- 自动化多步骤任务，降低人工切换成本
- 优先复用 SOP，让经验沉淀可持续
- 工具调用过程可观测、可回溯，便于审计

**详细说明**：
- **降低人工成本**：传统方式下，完成一个复杂任务（如竞品调研）需要人工切换多个工具：打开浏览器搜索、整理信息、写文档、保存文件等。Agent 可以自动化整个流程，用户只需给出一个指令，Agent 就能完成所有步骤，大大减少人工操作时间。
- **知识复用**：每次执行任务时，Agent 会优先搜索历史经验。如果之前有类似的 SOP（标准操作流程），可以直接复用，避免重复劳动。随着使用次数增加，知识库越来越丰富，Agent 的执行效率也会越来越高。
- **可观测性**：Agent 的每一步操作都会被记录，包括调用了什么工具、传入了什么参数、返回了什么结果。这种完整的执行轨迹不仅便于调试和优化，也满足了审计需求，让自动化过程透明可控。

## 项目一页图（PPT 可直接引用）
- **前端**：Next.js + App Router，SSE 流式展示
- **后端**：Next API Routes + OpenAI Chat Completions
- **工具层**：经验搜索 / todo 拆解 / 浏览器自动化 / 磁盘读写
- **存储**：Acontext 负责 Session/Space/Disk，Supabase 负责鉴权与索引
- **记忆**：对话、SOP、产物各自落地，形成长期资产

**架构说明**：
- **前端层**：采用 Next.js 的 App Router 架构，通过 Server-Sent Events (SSE) 实现实时流式输出。用户可以看到 Agent 的思考过程和工具调用进度，而不是等待最终结果，提升了交互体验。
- **后端层**：使用 Next.js API Routes 作为后端服务，集成 OpenAI 的 Chat Completions API。后端负责处理用户请求、管理对话上下文、协调工具调用、流式返回结果。
- **工具层**：这是 Agent 的"手和脚"，包括经验搜索（从 Acontext Space 检索历史 SOP）、todo 拆解（将复杂任务分解为可执行步骤）、浏览器自动化（使用 Browser Use 进行网页操作）、磁盘读写（文件系统的增删改查）等。
- **存储层**：采用双存储架构。Acontext 负责核心数据存储：Session（对话记录）、Space（知识库/SOP）、Disk（文件产物）。Supabase 负责用户鉴权和数据索引，提供快速检索能力。
- **记忆机制**：所有数据都会持久化存储。对话记录保存在 Session 中，SOP 和经验沉淀在 Space 中，生成的文件产物存储在 Disk 中。这些数据形成 Agent 的长期记忆，可以跨会话复用。

## 什么是 Acontext（本项目的基础平台）
- **Acontext 是什么**：Acontext 是一个上下文数据平台（Context Data Platform），专为构建云原生的 AI Agent 应用而设计
- **为什么需要 Acontext**：构建优秀的 Agent 应用需要解决上下文管理、长期记忆、可观测性、自动学习等核心问题，Acontext 提供了开箱即用的解决方案
- **本项目与 Acontext 的关系**：本项目是集成 Acontext 的客户端应用，通过 Acontext API 获得强大的上下文能力

**Acontext 详细介绍**：
- **Acontext 平台定位**：Acontext 是一个上下文数据平台，旨在帮助开发者构建能够服务百万用户、长期运行、可观测、能够从成功和失败中学习的 Agent 应用。它提供了统一的 API 来管理 Agent 的上下文数据，包括对话历史、知识库、文件产物等。

- **五大核心价值**（根据官方文档）：
  - **Context Engineering（上下文工程）**：自动进行上下文工程，通过一次 API 调用为 Agent 构建紧凑的上下文，优化 token 使用。
  - **Persistent Context（持久化上下文）**：持久化存储对话和产物，支持文本、图片、文件等多种格式，跨会话保持上下文连续性。
  - **Observability（可观测性）**：监控 Agent 的计划与实际执行情况，提供任务追踪、消息状态监控、会话分析等能力。
  - **Automatic Learning（自动学习）**：Agent 可以从已完成的任务中自动学习技能，无需手动训练。当 Session 连接到 Space 时，成功完成的任务会自动被分析并转化为可复用的 SOP。
  - **Dashboard（仪表盘）**：提供统一的视图来查看 Agent 的任务、对话和学到的技能，便于管理和分析。

- **三大核心资源**：
  - **Session（会话）**：每个对话会话对应一个 Acontext Session。Session 管理对话历史，支持语义搜索（根据当前问题找到相关的历史对话），支持上下文压缩（自动优化 token 使用）。当 Session 连接到 Space 时，还可以自动学习任务为 SOP。Session 还提供可观测性功能，可以追踪任务执行状态。
  - **Space（知识库）**：Space 是 Agent 的"经验库"。可以存储 SOP（标准操作流程）、技能文档、最佳实践等。Agent 在执行任务前，会先搜索 Space，看是否有可复用的经验。更重要的是，当 Session 连接到 Space 时，Acontext 会自动从成功完成的任务中学习技能和 SOP，实现"越用越聪明"的效果。
  - **Disk（文件存储）**：Disk 是 Agent 的"文件系统"。Agent 可以通过文件系统工具（Filesystem Tools）自主读写文件、管理产物。所有文件都存储在 Acontext Disk 中，支持版本管理、权限控制。Agent 通过 Function Calling 可以自主操作 Disk，实现文件的自动化管理。

- **本项目与 Acontext 的集成方式**：
  - **客户端架构**：本项目是一个集成 Acontext 的客户端应用。它通过 Acontext SDK（`@acontext/acontext`）调用 Acontext API，获得 Session、Space、Disk 的能力。
  - **数据流向**：用户在前端发起对话 → 后端创建/复用 Acontext Session → Agent 执行任务时调用 Space 搜索经验、调用 Disk 读写文件 → 所有数据最终存储在 Acontext 平台 → 前端通过 SSE 实时展示进度。
  - **可选集成**：Acontext 集成是可选的。如果未配置 `ACONTEXT_API_KEY`，系统会优雅降级，基本聊天功能仍然可用，只是失去了长期记忆和知识库能力。这保证了系统的灵活性。

- **使用 Acontext 的价值**：
  - **快速开发**：无需自己实现上下文管理、语义搜索、文件存储、自动学习等复杂功能，直接使用 Acontext 提供的成熟能力。
  - **生产就绪**：Acontext 提供了企业级的数据管理能力，包括数据持久化、高可用、权限控制、可观测性等，可以直接用于生产环境。
  - **自动学习**：通过将 Session 连接到 Space，Agent 可以自动从成功任务中学习技能和 SOP，无需手动训练，实现真正的"越用越聪明"。
  - **持续优化**：Acontext 平台会持续优化上下文压缩算法、语义搜索精度、学习算法等，使用 Acontext 的应用会自动受益于这些优化。

- **如何开始使用 Acontext**：
  - 访问 [Acontext 官网](https://acontext.io) 注册账号
  - 获取 API Key，配置到环境变量 `ACONTEXT_API_KEY`
  - 本项目会自动检测配置，启用 Acontext 集成
  - 详细文档参考：[Acontext 文档](https://docs.acontext.io)

## 流程拆解（可画泳道图）
1. 用户请求 → API 校验权限与可用工具
2. 历史消息压缩，准备上下文
3. 系统提示强制"先经验、再规划"
4. LLM 工具循环：经验搜索 → todo → 浏览器/磁盘等
5. 结果写回 Acontext，并通过 SSE 实时反馈

**详细流程说明**：
1. **请求接收与校验**：用户在前端输入任务指令，前端通过 API 发送请求。后端首先校验用户身份（通过 Supabase 鉴权），然后根据用户权限确定可用的工具列表（工具白名单机制）。
2. **上下文准备**：为了给 LLM 提供足够的上下文，系统会读取历史对话记录。如果对话过长，会进行智能压缩：优先保留重要的工具调用结果和用户指令，丢弃冗余的闲聊内容，确保上下文在 token 限制内。
3. **系统提示注入**：在发送给 LLM 的提示中，系统会强制要求 Agent 遵循"先经验、再规划"的工作流。即：先搜索历史经验库看是否有可复用的 SOP，然后再制定新的执行计划。这确保了知识优先复用。
4. **工具调用循环**：LLM 进入工具调用循环。首先调用"经验搜索"工具查找相关 SOP；如果没有找到，调用"todo"工具将任务拆解成步骤；然后根据计划依次调用"浏览器"、"磁盘"等工具执行具体操作。每次工具调用后，LLM 会根据结果决定下一步行动，直到任务完成。
5. **结果持久化与反馈**：任务执行过程中，每一步的结果都会实时通过 SSE 流式返回给前端，用户可以看到进度。任务完成后，所有结果（对话记录、新生成的 SOP、文件产物）都会写入 Acontext 的相应存储空间，形成长期记忆。

## 我的 Agent 设计理念（Main Agent + Tools）
- **一个 Main Agent**：负责理解用户意图、拆解任务、选择合适工具，是"总调度大脑"。
- **Tool 不只是函数**：在设计里，Tool 可以是：
  - **Sub-Agent**：比如接入 Claude、Code 专用 Agent，用于写代码、改文档等专业子任务；
  - **Workflow**：步骤很确定的一整条流水线（如固定 ETL、固定发布流程），对外以一个 Tool 暴露；
  - **普通函数型能力**：如磁盘读写、知识库检索、发 HTTP 请求等原子操作。
- **统一抽象**：无论是 Sub-Agent、Workflow 还是 Function，在 Main Agent 看来都是"可以调用的 Tool"，用同一套 schema 与日志体系管理。
- **设计目标**：既保留足够灵活度（可以挂各种智能体），又通过 Tool 白名单和强约束流程保证可控与可观测。

**设计理念详细说明**：
- **Main Agent 的核心作用**：Main Agent 是整个系统的"总指挥"，它不直接执行具体操作，而是负责理解用户意图、评估任务复杂度、规划执行步骤、选择合适的工具、协调工具执行顺序、处理工具返回结果、生成最终回答。这种"大脑+手脚"的架构让系统既有智能决策能力，又有强大的执行能力。

- **Tool 的三种形态**：
  - **Sub-Agent**：当任务需要专业能力时，Main Agent 可以调用专门的 Sub-Agent。例如代码任务可以调用 Code Agent（使用 Claude 模型，专门优化代码生成），文档任务可以调用文案 Agent。每个 Sub-Agent 有独立的上下文和配置，可以专注于特定领域。
  - **Workflow**：对于固定流程的任务，可以封装成 Workflow Tool。例如"竞品调研"Workflow 内部包含：搜索网站、提取信息、整理文档、保存文件等步骤。对 Main Agent 来说，调用 Workflow 就像调用一个普通工具，但内部执行了复杂的多步流程。这提高了执行效率和可靠性。
  - **Function**：最基础的原子能力，如磁盘读写、知识库检索、HTTP 请求等。这些是构建 Sub-Agent 和 Workflow 的基础组件。

- **统一抽象的价值**：无论 Tool 是 Sub-Agent、Workflow 还是 Function，在 Main Agent 看来都是"可以调用的 Tool"。它们使用统一的 schema（参数定义）和日志体系（调用记录）。这种统一抽象让系统架构简洁清晰，易于扩展和维护。

- **灵活性与可控性的平衡**：设计目标是既保留足够的灵活度（可以接入各种智能体和工具），又通过工具白名单和强约束流程保证可控性和可观测性。这样既能让 Agent 发挥创造力，又能确保它在安全边界内运行。

## 核心卖点
- **硬约束工作流**：经验优先 + 先规划后行动
- **长期记忆**：Space/SOP 与 Disk 产物越用越多
- **可观测性**：每次 tool call 可追踪参数与结果
- **易扩展**：新增工具仅需提供 schema 与 executor
- **安全守护**：用户鉴权、白名单、超时与降级策略

**详细说明**：
- **硬约束工作流**：系统通过强制的系统提示和流程控制，确保 Agent 必须遵循"先搜索经验、再制定规划、最后执行行动"的顺序。这避免了 Agent 盲目执行，提高了任务成功率。
- **长期记忆**：所有执行过程和结果都会持久化。Space 中积累的 SOP 越来越多，Disk 中存储的产物文件越来越多。随着使用次数增加，Agent 的知识库不断丰富，执行效率持续提升。
- **可观测性**：每次工具调用都会被完整记录：工具名称、输入参数、执行结果、耗时等。这些日志不仅用于调试，也让用户清楚了解 Agent 的执行过程，建立信任。
- **易扩展**：新增工具非常简单，只需要定义工具的 schema（参数结构）和 executor（执行函数）。系统会自动将新工具注册到工具列表，Agent 就可以调用它。这支持快速接入新的能力。
- **安全守护**：多层安全机制：用户鉴权确保只有授权用户可以使用；工具白名单限制 Agent 只能调用允许的工具；超时保护防止工具调用卡死；降级策略在外部服务不可用时提供友好提示。

## 关键技术点
- OpenAI gpt-4o/4.1，工具调用与最终回答分温度配置
- 上下文压缩策略：优先丢弃旧工具结果与闲聊
- 浏览器自动化：Browser Use，同步/流式模式，单次 5 分钟
- Acontext 深度集成：Session/Space/Disk 全链路托管
- 安全与降级：URL 校验、工具白名单、缺 Key 时友好提示

**技术细节说明**：
- **LLM 配置**：使用 OpenAI 的 gpt-4o 或 gpt-4.1 模型。在工具调用阶段，使用较高的温度（如 0.7）以鼓励探索和尝试；在生成最终回答时，使用较低的温度（如 0.3）以保证回答的准确性和稳定性。
- **上下文压缩**：当对话历史过长时，系统会智能压缩上下文。压缩策略是：优先保留用户指令和关键工具调用结果，丢弃旧的工具调用细节和闲聊内容。这确保了重要信息不丢失，同时控制 token 消耗。
- **浏览器自动化**：使用 Browser Use 库实现浏览器自动化。支持同步模式（等待操作完成）和流式模式（实时返回进度）。每次浏览器操作有 5 分钟超时限制，防止长时间卡死。
- **Acontext 集成**：深度集成 Acontext 的三大存储能力：Session（对话记录管理）、Space（知识库/SOP 存储与检索）、Disk（文件产物存储）。所有数据都通过 Acontext API 统一管理，保证了数据的一致性和可靠性。
- **安全机制**：URL 校验确保浏览器只能访问允许的域名；工具白名单限制 Agent 只能调用授权的工具；当 API Key 缺失时，系统会优雅降级，提示用户配置，而不是直接报错。

## 当前工具盘点（可按需精简成一页）
- **Main Agent**：
  - 负责：意图理解、任务拆解、选择/编排 Tool、做最终回答。
  - 特点：工具调用温度较高以探索步骤，最终回答温度较低保证稳健。
- **Sub-Agent 类 Tool（示例）**：
  - Claude/Code Agent：适合代码生成、重构、性能分析等，需要单独上下文与偏好配置。
  - 文案/总结 Agent：对长文做总结、翻译、改写等。
- **Workflow 类 Tool**：
  - 例如"固定竞品调研流水线"、"固定日志分析流水线"，内部包含多步浏览器/磁盘/总结调用，对 Main Agent 来说是一个原子 Tool。
- **Function 类 Tool**：
  - 经验搜索（Space 检索）、todo 拆解、浏览器自动化、磁盘读写、HTTP 调用等。
  - 这些工具组合起来，为 Sub-Agent 和 Workflow 提供基础能力。

**工具使用场景说明**：
- **Main Agent**：是整个系统的"大脑"，负责理解用户意图、规划任务步骤、选择合适的工具、协调工具执行、生成最终回答。它是所有工具的统一调度中心。
- **Sub-Agent 类 Tool**：当任务需要专业能力时，Main Agent 可以调用专门的 Sub-Agent。例如代码任务调用 Code Agent（使用 Claude 模型，专门优化代码生成），文案任务调用文案 Agent（专门处理文本总结、翻译等）。每个 Sub-Agent 有独立的上下文和配置。
- **Workflow 类 Tool**：对于固定流程的任务，可以封装成 Workflow Tool。例如"竞品调研"Workflow 内部包含：搜索相关网站、提取信息、整理成 Markdown、保存文件等步骤。对 Main Agent 来说，调用 Workflow 就像调用一个普通工具，但内部执行了复杂的多步流程。
- **Function 类 Tool**：这是最基础的原子能力。经验搜索用于从知识库检索 SOP；todo 拆解用于将复杂任务分解；浏览器自动化用于网页操作；磁盘读写用于文件管理；HTTP 调用用于 API 请求。这些基础工具可以组合使用，也可以被 Sub-Agent 和 Workflow 内部调用。

## 典型场景
- **竞品/技术调研**：模板 → todo → 浏览器采集 → Markdown 输出
- **代码/文档处理**：磁盘读写 → 改写 → 回写 → 提供下载
- **SOP 积累**：任务完成后沉淀经验块，经验搜索直接命中

**场景详细说明**：
- **竞品/技术调研场景**：
  1. 用户输入："帮我调研一下 Next.js 的最新特性"
  2. Agent 先搜索经验库，看是否有类似的调研模板或 SOP
  3. 使用 todo 工具将任务拆解：搜索官方文档、查看 GitHub 更新、阅读相关博客、整理成报告
  4. 依次调用浏览器工具访问相关网站，提取关键信息
  5. 将收集的信息整理成结构化的 Markdown 文档
  6. 保存到 Disk，并提供下载链接
  7. 将本次调研的流程沉淀为 SOP，供下次复用

- **代码/文档处理场景**：
  1. 用户上传一个代码文件或文档，要求"优化这段代码"或"改写这篇文档"
  2. Agent 使用磁盘工具读取文件内容
  3. 调用 Code Agent 或文案 Agent 进行改写
  4. 将改写后的内容写回磁盘
  5. 通过前端提供下载或预览功能
  6. 整个过程支持流式输出，用户可以看到改写进度

- **SOP 积累场景**：
  1. 每次任务完成后，Agent 会自动提取执行过程中的关键步骤和经验
  2. 将这些经验整理成结构化的 SOP（标准操作流程）
  3. 保存到 Acontext Space 知识库
  4. 下次遇到类似任务时，经验搜索工具可以直接命中这些 SOP
  5. Agent 可以直接复用 SOP，无需重新规划，大大提升效率

## 风险与对策
- 工具滥用 → 系统提示 + 白名单限制
- 上下文爆炸 → 自动压缩 + 手动触发强压缩
- 外部依赖失效 → 缺凭据时自动降级并提示
- 浏览器不稳定 → 超时保护，建议缩小任务
- 数据落地不一致 → 统一落在 Acontext，Supabase 仅存索引

**风险详细说明与对策**：
- **工具滥用风险**：Agent 可能会过度调用工具，或者调用不合适的工具，导致资源浪费或安全问题。
  - **对策**：通过系统提示明确告知 Agent 工具的使用场景和限制；实施工具白名单机制，只允许 Agent 调用授权的工具；记录所有工具调用日志，便于审计和优化。

- **上下文爆炸风险**：长时间对话或复杂任务会导致上下文过长，超出 LLM 的 token 限制，影响性能和成本。
  - **对策**：实现智能上下文压缩算法，优先保留重要信息（用户指令、关键工具结果），丢弃冗余内容（旧工具细节、闲聊）；提供手动触发强压缩功能，用户可以在需要时主动清理上下文。

- **外部依赖失效风险**：Agent 依赖的外部服务（如 OpenAI API、浏览器服务）可能出现故障或 API Key 失效。
  - **对策**：在检测到 API Key 缺失或服务不可用时，系统会优雅降级，给出友好的提示信息，而不是直接报错；对于关键工具，提供备用方案或降级策略。

- **浏览器不稳定风险**：浏览器自动化可能因为网页加载慢、元素找不到等原因卡死或失败。
  - **对策**：设置 5 分钟超时保护，超时后自动终止浏览器操作；建议用户将大任务拆解成小任务，降低单次浏览器操作的复杂度；记录浏览器操作的详细日志，便于定位问题。

- **数据落地不一致风险**：数据可能分散存储在多个地方，导致数据不一致或难以管理。
  - **对策**：统一使用 Acontext 作为核心数据存储（Session、Space、Disk），Supabase 仅用于用户鉴权和数据索引，不存储实际内容。这确保了数据的单一数据源（Single Source of Truth）。

## Demo 建议
- 现场演示"竞品调研"任务，突出 SSE 工具进度
- 展示经验搜索命中历史 SOP，强调知识复用
- 打开磁盘文件，证明产物落地与记忆能力
- **在线体验**：[Acontext Agent Playground](https://acontext-agent-playground.vercel.app/)

**演示要点说明**：
- **SSE 流式展示**：演示时重点展示前端如何实时显示 Agent 的思考过程和工具调用进度。用户可以看到 Agent 正在"思考"、"搜索经验"、"调用浏览器"、"保存文件"等每一步操作，而不是等待最终结果。这体现了系统的可观测性和交互体验优势。

- **经验搜索演示**：演示一个之前执行过的任务（如"调研 React 18 新特性"），展示 Agent 如何通过经验搜索直接命中历史 SOP，然后快速复用，无需重新规划。这体现了知识积累和复用的价值。

- **产物落地演示**：任务完成后，打开 Acontext Disk 或本地文件系统，展示 Agent 生成的实际文件（Markdown 文档、代码文件等）。这证明了 Agent 不仅能执行任务，还能产生可用的实际产物，形成长期资产。

- **在线体验**：提供在线演示地址，让听众可以亲自体验。建议准备几个预设任务，方便快速演示核心功能。

## 课后行动
- 从可观测工具入手试用（经验搜索、todo）
- 梳理自身流程并固化 SOP 供 Agent 调用
- 逐步补充限制条件与日志监控，提升可靠性

**行动指南说明**：
- **从可观测工具入手**：建议先从经验搜索和 todo 这两个工具开始试用。它们执行速度快、结果清晰可见，可以帮助理解 Agent 的工作方式。经验搜索可以看到知识库的内容，todo 可以看到任务拆解的逻辑。

- **固化 SOP**：梳理自己日常工作中的重复性流程，将其整理成标准化的 SOP。例如："每周技术周报生成流程"、"代码审查检查清单"、"项目启动检查项"等。将这些 SOP 存入 Acontext Space，Agent 就可以在后续任务中直接复用。

- **逐步完善**：不要一开始就追求完美。先让 Agent 跑通基本流程，然后逐步添加限制条件（如工具白名单、超时设置等）和日志监控（如工具调用统计、错误追踪等），持续提升系统的可靠性和可控性。

## 相关链接
- **在线演示**：[Acontext Agent Playground](https://acontext-agent-playground.vercel.app/)
  - 可以直接体验 Agent 的各项功能，包括经验搜索、任务拆解、浏览器自动化等
- **GitHub 仓库**：[Acontext-Agent-Playground](https://github.com/mbt1909432/Acontext-Agent-Playground)
  - 包含完整的源代码、技术文档和使用说明，可以深入了解实现细节

